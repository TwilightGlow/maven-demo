package com.example.interpreter;

/**
 * @author zhangjw54
 *
 * 介绍:
 * 解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的 “语言” 是指使用规定格式和语法的代码。解释器模式是一种类行为型模式。
 *
 * 角色:
 * AbstractExpression（抽象解释器）：在抽象表达式中声明了抽象的解释操作,具体的解释任务由各个实现类完成,它是所有终结符表达式和非终结符表达式的公共父类。
 *
 * TerminalExpression（终结符表达式）：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结表达式，但有多个实例，对应不同的终结符。
 *
 * NonterminalExpression（非终结符表达式）：文法中的每条规则对应于一个非终结表达式，非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式
 *
 * Context（环境类）：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。
 *
 * 客户类（Test）: 客户端,解析表达式,构建抽象语法树,执行具体的解释操作等.
 *
 * 总结:
 * 解释器模式为自定义语言的设计和实现提供了一种解决方案，它用于定义一组文法规则并通过这组文法规则来解释语言中的句子。虽然解释器模式的使用频率不是特别高，但是它在正则表达式、XML文档解释等领域还是得到了广泛使用。
 *
 * 优点:
 *  易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。
 *  每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。
 *  实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。
 *  增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合"开闭原则"。
 *
 * 缺点:
 *  对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。
 *  执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。
 *
 *  在SpEL中有使用到解释器模式
 *  其中Expression是一个接口，相当于我们解释器模式中的非终结符表达式，
 *  而ExpressionParser相当于终结符表达式。根据不同的Parser对象，返回不同的Expression对象
 */
public interface Expression {

    int interpreter(Context context);
}
